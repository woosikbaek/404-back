import paho.mqtt.client as mqtt
import os
import json
import base64
from datetime import datetime
from dotenv import load_dotenv

from models.car import Car
from models.sensor_result import SensorResult
from models.camera_result import CameraResult
from extensions import db
from sqlalchemy import func

# .env íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°
load_dotenv()

broker = os.getenv("MQTT_BROKER")
port = int(os.getenv("MQTT_PORT"))

TOPIC_CAMERA01_RESULT = os.getenv("MQTT_TOPIC_CAMERA01_RESULT")
TOPIC_SENSOR_RESULT = os.getenv("MQTT_TOPIC_SENSOR_RESULT")

client = mqtt.Client()

_flask_app = None
_socketio = None
current_car_id = None


# ==================== í†µê³„ ê³„ì‚° í•¨ìˆ˜ ====================

def calc_rate(defect_count, total_count):
    """ë¶ˆëŸ‰ë¥  ê³„ì‚°"""
    if total_count == 0:
        return 0
    return round((defect_count / total_count) * 100, 2)


def calculate_stats():
    """ì „ì²´ í†µê³„ ë°ì´í„° ê³„ì‚°"""
    
    # ì „ì²´ ìë™ì°¨ ìˆ˜
    total_count = Car.query.count()
    
    # ===== ì„¼ì„œ í†µê³„ =====
    # ì„¼ì„œ ë¶ˆëŸ‰ ì°¨ëŸ‰ ìˆ˜ (ì¤‘ë³µ ì œê±°)
    sensor_defect_car_count = (
        db.session.query(func.count(func.distinct(SensorResult.car_id)))
        .filter(SensorResult.result == 'defect')
        .scalar()
    ) or 0
    
    # ì„¼ì„œ ë¶ˆëŸ‰ ë¡œê·¸ ìˆ˜ (ì „ì²´)
    sensor_defect_log_count = (
        SensorResult.query.filter(SensorResult.result == 'defect').count()
    ) or 0
    
    # ì„¼ì„œ ì¥ì¹˜ë³„ í†µê³„
    sensor_by_device_raw = (
        db.session.query(
            SensorResult.device,
            func.count(func.distinct(SensorResult.car_id)),  # ì¥ì¹˜ë³„ ë¶ˆëŸ‰ ì°¨ëŸ‰ ìˆ˜
            func.count(SensorResult.id)  # ì¥ì¹˜ë³„ ë¶ˆëŸ‰ ë¡œê·¸ ìˆ˜
        )
        .filter(SensorResult.result == 'defect')
        .group_by(SensorResult.device)
        .all()
    )
    
    sensor_by_device = {}
    for device, car_count, log_count in sensor_by_device_raw:
        sensor_by_device[device] = {
            "defect_car_count": car_count,
            "car_defect_rate": calc_rate(car_count, sensor_defect_car_count),  # ì„¼ì„œ ë¶ˆëŸ‰ ì°¨ëŸ‰ ì¤‘ ë¹„ìœ¨
            "defect_log_count": log_count,
            "log_defect_rate": calc_rate(log_count, sensor_defect_log_count)  # ì„¼ì„œ ë¶ˆëŸ‰ ë¡œê·¸ ì¤‘ ë¹„ìœ¨
        }
    
    # ===== ì™¸ê´€ í†µê³„ =====
    # ì™¸ê´€ ë¶ˆëŸ‰ ì°¨ëŸ‰ ìˆ˜ (ì¤‘ë³µ ì œê±°)
    camera_defect_car_count = (
        db.session.query(func.count(func.distinct(CameraResult.car_id)))
        .filter(CameraResult.result == 'defect')
        .scalar()
    ) or 0
    
    # ì™¸ê´€ ë¶ˆëŸ‰ ë¡œê·¸ ìˆ˜
    camera_defect_log_count = (
        CameraResult.query.filter(CameraResult.result == 'defect').count()
    ) or 0
    
    # ===== ì „ì²´ í†µê³„ =====
    # ì „ì²´ ë¶ˆëŸ‰ ì°¨ëŸ‰ ìˆ˜ (ì„¼ì„œ âˆª ì™¸ê´€ - í•©ì§‘í•©)
    overall_defect_car_count = (
        db.session.query(func.count(func.distinct(Car.id)))
        .filter(
            Car.id.in_(
                db.session.query(SensorResult.car_id)
                .filter(SensorResult.result == 'defect')
                .union(
                    db.session.query(CameraResult.car_id)
                    .filter(CameraResult.result == 'defect')
                )
            )
        )
        .scalar()
    ) or 0
    
    # ì „ì²´ ë¶ˆëŸ‰ ë¡œê·¸ ìˆ˜ (ì„¼ì„œ + ì™¸ê´€)
    overall_defect_log_count = sensor_defect_log_count + camera_defect_log_count
    
    # ì „ì²´ ì •ìƒ ì°¨ëŸ‰ ìˆ˜ (ì „ì²´ - ë¶ˆëŸ‰)
    overall_normal_car_count = total_count - overall_defect_car_count
    
    return {
        "total_count": total_count,
        
        "overall": {
            "normal_car_count": overall_normal_car_count,
            "defect_car_count": overall_defect_car_count,
            "defect_rate": calc_rate(overall_defect_car_count, total_count),
            "defect_log_count": overall_defect_log_count
        },
        
        "sensor": {
            "defect_car_count": sensor_defect_car_count,
            "defect_rate": calc_rate(sensor_defect_car_count, total_count),
            "defect_log_count": sensor_defect_log_count,
            "by_device": sensor_by_device
        },

        "camera": {
            "defect_car_count": camera_defect_car_count,
            "defect_rate": calc_rate(camera_defect_car_count, total_count),
            "defect_log_count": camera_defect_log_count
        }
    }


def emit_stats_update():
    """í†µê³„ ì—…ë°ì´íŠ¸ WebSocket ë°œì†¡"""
    if _socketio:
        stats = calculate_stats()
        _socketio.emit('stats_update', stats)
        print(f"[WebSocket] í†µê³„ ì—…ë°ì´íŠ¸ ë°œì†¡")


def emit_sensor_defect(sensor_data):
    """ì„¼ì„œ ë¶ˆëŸ‰ WebSocket ì´ë²¤íŠ¸ ë°œì†¡"""
    if _socketio:
        _socketio.emit('sensor_defect', sensor_data)
        emit_stats_update()
        print(f"[WebSocket] ì„¼ì„œ ë¶ˆëŸ‰ ë°œì†¡: {sensor_data}")


def emit_camera_defect(camera_data):
    """ì¹´ë©”ë¼ ë¶ˆëŸ‰ WebSocket ì´ë²¤íŠ¸ ë°œì†¡"""
    if _socketio:
        _socketio.emit('camera_defect', camera_data)
        emit_stats_update()
        print(f"[WebSocket] ì¹´ë©”ë¼ ë¶ˆëŸ‰ ë°œì†¡: {camera_data}")


# MQTT ì—°ê²° ì„±ê³µ
def on_connect(client, userdata, flags, rc):
    print("MQTT ì—°ê²°ë¨")
    client.subscribe(TOPIC_CAMERA01_RESULT)
    client.subscribe(TOPIC_SENSOR_RESULT)


# ì„¼ì„œ ê²°ê³¼ ì €ì¥
def save_sensor_result(data):
    global current_car_id

    device = data['device']
    result = data['result']  # ok / defect

    # LED ê²°ê³¼ë©´ ì°¨ ìƒì„± (ë”± í•œ ë²ˆ)
    if device == 'LED':
        car = Car()
        db.session.add(car)
        db.session.commit()
        current_car_id = car.id
        print(f"[ì‹ ê·œ ì°¨ëŸ‰] Car ID: {current_car_id}")

    # ì•ˆì „ì¥ì¹˜
    if current_car_id is None:
        return

    sensor = SensorResult(
        car_id=current_car_id,
        device=device,
        result=result
    )
    db.session.add(sensor)
    db.session.commit()
    
    # ğŸ’¡ ë¶ˆëŸ‰ ì•Œë¦¼ ë°œì†¡ (LED, BUZZER, SUPERSONIC)
    sensor_data = {
        'car_id': sensor.car_id,
        'device': sensor.device,
        'result': sensor.result,
        'created_at': sensor.created_at.isoformat()
    }
    
    if sensor.result == 'defect':
        emit_sensor_defect(sensor_data)
    
    # âš ï¸ WHEELì´ ì˜¬ ë•Œê¹Œì§€ í†µê³„ ì—…ë°ì´íŠ¸ ì•ˆ í•¨ (WHEELì´ ë§ˆì§€ë§‰ì´ë¯€ë¡œ)
    if device == 'WHEEL':
        # ì£¼í–‰ ê²€ì‚¬ ì™„ë£Œ = ëª¨ë“  ê²€ì‚¬ ì™„ë£Œ
        emit_stats_update()
        print(f"[ê²€ì‚¬ ì™„ë£Œ] Car ID {current_car_id} ëª¨ë“  ê²€ì‚¬ ì™„ë£Œ - í†µê³„ ì—…ë°ì´íŠ¸ ë°œì†¡")


# ì™¸ê´€ ì´ë¯¸ì§€ ì €ì¥
def save_camera_result_image(base64_str):
    save_dir = "uploads/camera"
    os.makedirs(save_dir, exist_ok=True)

    filename = datetime.now().strftime("%Y%m%d_%H%M%S_%f") + ".jpg"
    file_path = os.path.join(save_dir, filename)

    image_bytes = base64.b64decode(base64_str)

    with open(file_path, "wb") as f:
        f.write(image_bytes)

    return file_path


# ì™¸ê´€ ê²°ê³¼ ì €ì¥
def save_camera_result(data):
    global current_car_id

    if current_car_id is None:
        return

    image_path = None
    if data.get('image'):
        image_path = save_camera_result_image(data['image'])

    camera = CameraResult(
        car_id=current_car_id,
        result=data['result'],
        image_path=image_path
    )
    db.session.add(camera)
    db.session.commit()
    
    # ï¿½ ë¶ˆëŸ‰ ì•Œë¦¼ë§Œ ë°œì†¡ (ì™¸ê´€ ê²€ì‚¬)
    camera_data = {
        'car_id': camera.car_id,
        'result': camera.result,
        'image': camera.image_path,
        'created_at': camera.created_at.isoformat()
    }
    
    if camera.result == 'defect':
        emit_camera_defect(camera_data)
    
    # âš ï¸ ì™¸ê´€ ê²€ì‚¬ ì™„ë£Œ í›„ ì£¼í–‰(WHEEL)ì´ ì˜¬ ë•Œê¹Œì§€ í†µê³„ ì—…ë°ì´íŠ¸ ì•ˆ í•¨


# ë©”ì‹œì§€ ìˆ˜ì‹ 
def on_message(client, userdata, msg):
    data = json.loads(msg.payload.decode())

    with _flask_app.app_context():
        if msg.topic == TOPIC_SENSOR_RESULT:
            save_sensor_result(data)
            print(data)

        elif msg.topic == TOPIC_CAMERA01_RESULT:
            save_camera_result(data)
            print(data)


client.on_connect = on_connect
client.on_message = on_message


def mqtt_connect(app, socketio):
    global _flask_app, _socketio
    _flask_app = app
    _socketio = socketio

    client.connect(broker, port)
    client.loop_start()


def publish(topic, message):
    client.publish(topic, message)